<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>robotoc: Features of optimal control solvers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">robotoc
   </div>
   <div id="projectbrief">robotoc - efficient ROBOT Optimal Control solvers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('page_features.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Features of optimal control solvers </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#solvers_list">List of optimal control solvers</a></li>
<li class="level1"><a href="#common_features">Common features among solvers</a></li>
<li class="level1"><a href="#ocp_solver">robotoc::OCPSolver</a><ul><li class="level2"><a href="#ocp_solver_features">Features</a></li>
<li class="level2"><a href="#ocp_solver_formulation">Methematical formulation</a></li>
<li class="level2"><a href="#ocp_solver_algorithm">Solution algorithm</a></li>
</ul>
</li>
<li class="level1"><a href="#unconstr_ocp_solver">robotoc::UnconstrOCPSolver</a><ul><li class="level2"><a href="#unconstr_ocp_solver_features">Features</a></li>
<li class="level2"><a href="#unconstr_ocp_solver_formulation">Methematical formulation</a></li>
<li class="level2"><a href="#unconstr_ocp_solver_algorithm">Solution algorithm</a></li>
</ul>
</li>
<li class="level1"><a href="#unconstr_parnmpc_solver">robotoc::UnconstrParNMPCSolver</a><ul><li class="level2"><a href="#unconstr_parnmpc_solver_features">Features</a></li>
<li class="level2"><a href="#unconstr_parnmpc_solver_formulation">Methematical formulation</a></li>
<li class="level2"><a href="#unconstr_parnmpc_solver_algorithm">Solution algorithm</a></li>
</ul>
</li>
<li class="level1"><a href="#features_references">References</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="solvers_list"></a>
List of optimal control solvers</h1>
<p >The following three solvers are available:</p><ul>
<li><code><a class="el" href="classrobotoc_1_1_o_c_p_solver.html" title="Optimal control problem solver by Riccati recursion.">robotoc::OCPSolver</a></code>: Optimal control solver for robot systems with rigid contacts and/or a floating base. This solver can optimize the trajectory and switching times simultaneously.</li>
<li><code><a class="el" href="classrobotoc_1_1_unconstr_o_c_p_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by Riccati recursion....">robotoc::UnconstrOCPSolver</a></code>: Optimal control solver for robot systems without rigid contacts or a floating base. More efficient than <code><a class="el" href="classrobotoc_1_1_o_c_p_solver.html" title="Optimal control problem solver by Riccati recursion.">robotoc::OCPSolver</a></code>.</li>
<li><code><a class="el" href="classrobotoc_1_1_unconstr_par_n_m_p_c_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by ParNMPC algorithm....">robotoc::UnconstrParNMPCSolver</a></code>: Optimal control solver for robot systems without rigid contacts or a floating base. Possibly very efficient when the number of available CPU cores is very large.</li>
</ul>
<h1><a class="anchor" id="common_features"></a>
Common features among solvers</h1>
<p >The common features in mathematical formulation, algorithms, and implementation among these three solvers are as follows:</p><ul>
<li><b>Direct multiple shooting method</b> [1, 2]:<ul>
<li>has a nice convergence property.</li>
<li>fully leverages parallel computation of the KKT system with OpenMP.</li>
</ul>
</li>
<li><b>Primal-dual interior point method</b> [3, 4]:<ul>
<li>can treat many inequality constraints including nonlinear ones very efficiently.</li>
<li>allows infeasible initial guess of the solution.</li>
<li>enables us to perform very fast suboptimal MPC by fixing the barrier parameter.</li>
</ul>
</li>
<li><b>Gauss-Newton method</b>:<ul>
<li>improves computational speed and numerical conditioning.</li>
</ul>
</li>
<li><b>Structure-exploting algorithms to compute Newton steps</b> [2, 4, 5]:<ul>
<li>can compute the Newton steps with linear time complexity with respect to the length of the horizon.</li>
</ul>
</li>
<li><b>Very fast rigid body kinematics and dynamics computation</b> thanks to <a href="https://github.com/stack-of-tasks/pinocchio">Pinocchio</a>.<ul>
<li><a href="https://github.com/stack-of-tasks/pinocchio">Pinocchio</a> provides very efficient forward kinematics, kinematics Jacobians, the recursive Newton Euler algorithm (RNEA), and derivatives of the RNEA [6].</li>
<li><a href="https://github.com/stack-of-tasks/pinocchio">Pinocchio</a> also gives us an interface to construct a robot model (<code><a class="el" href="classrobotoc_1_1_robot.html" title="Dynamics and kinematics model of robots. Wraps pinocchio::Model and pinocchio::Data....">robotoc::Robot</a></code>) via URDF files.</li>
</ul>
</li>
<li><b>Versatile cost function and constraints interface</b>:<ul>
<li>new cost compoments can be easily defined by inheriting <code><a class="el" href="classrobotoc_1_1_cost_function_component_base.html" title="Base class of components of cost function.">robotoc::CostFunctionComponentBase</a></code>.</li>
<li>The cost function can be easily be constructed by collecting cost components into <code><a class="el" href="classrobotoc_1_1_cost_function.html" title="Stack of the cost function. Composed by cost function components that inherits CostFunctionComponentB...">robotoc::CostFunction</a></code></li>
<li>new constraint compoments can be easily defined by inheriting <code><a class="el" href="classrobotoc_1_1_constraint_component_base.html" title="Base class for constraint components.">robotoc::ConstraintComponentBase</a></code> or <code><a class="el" href="classrobotoc_1_1_impact_constraint_component_base.html" title="Base class for impact constraint components.">robotoc::ImpactConstraintComponentBase</a></code>.</li>
<li>The constraints can be easily be constructed by collecting constraint components into <code><a class="el" href="classrobotoc_1_1_constraints.html" title="Stack of the inequality constraints. Composed by constraint components that inherits ConstraintCompon...">robotoc::Constraints</a></code></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="ocp_solver"></a>
robotoc::OCPSolver</h1>
<h2><a class="anchor" id="ocp_solver_features"></a>
Features</h2>
<p ><code><a class="el" href="classrobotoc_1_1_o_c_p_solver.html" title="Optimal control problem solver by Riccati recursion.">robotoc::OCPSolver</a></code> is an optimal control solver for robot systems with rigid contacts and/or a floating base. This is the main solver of <code>robotoc</code>. The unique features of <code><a class="el" href="classrobotoc_1_1_o_c_p_solver.html" title="Optimal control problem solver by Riccati recursion.">robotoc::OCPSolver</a></code> are:</p><ul>
<li><b>Multiphase optimal control problem</b> construction through the contact sequence interface:<ul>
<li><code><a class="el" href="classrobotoc_1_1_contact_sequence.html" title="The sequence of contact status and discrete events (impact and lift).">robotoc::ContactSequence</a></code> interface enables us to formulate the complicated optimal control problems involving changes of dynamics and state jumps due to rigid contacts.</li>
</ul>
</li>
<li><b>Lifted contact dynamics</b> [7]:<ul>
<li>Relaxes the high nonlinearity in optimization problems typically caused by inequality constraints treated by the interior point methods.</li>
</ul>
</li>
<li><b>Riccati recursion for switching time optimization (STO) problems</b> [8]:<ul>
<li>Computes the Newton steps including the switching times with linear time complexity with respect to the length of the horizon. Moreover, the Riccati-recursion-based Hessian modification improves numerical stability. <br  />
</li>
</ul>
</li>
<li><b>Constraint transformation of pure-state constraints for efficient Riccati recursion</b> [9]:<ul>
<li>The pure-state equality constraints representing the switching constraints are treated very efficiently while preserving accuracy and guaranteeing optimality by the constraint transformation.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ocp_solver_formulation"></a>
Methematical formulation</h2>
<p >TODO</p>
<h2><a class="anchor" id="ocp_solver_algorithm"></a>
Solution algorithm</h2>
<p >TODO</p>
<h1><a class="anchor" id="unconstr_ocp_solver"></a>
robotoc::UnconstrOCPSolver</h1>
<h2><a class="anchor" id="unconstr_ocp_solver_features"></a>
Features</h2>
<p ><code><a class="el" href="classrobotoc_1_1_unconstr_o_c_p_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by Riccati recursion....">robotoc::UnconstrOCPSolver</a></code> is an optimal control solver for robot systems without rigid contacts or a floating base. This is recommended than <code><a class="el" href="classrobotoc_1_1_o_c_p_solver.html" title="Optimal control problem solver by Riccati recursion.">robotoc::OCPSolver</a></code> for such systems. The unique features of <code><a class="el" href="classrobotoc_1_1_unconstr_o_c_p_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by Riccati recursion....">robotoc::UnconstrOCPSolver</a></code> are:</p><ul>
<li><b>Inverse dynamics based formulation</b> [10]:<ul>
<li>Inverse dynamics-based formulation enables very fast computation compared with the forward dynamics-based formulation. You can check this fact easily by comparing <code><a class="el" href="classrobotoc_1_1_unconstr_o_c_p_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by Riccati recursion....">robotoc::UnconstrOCPSolver</a></code> and <code><a class="el" href="classrobotoc_1_1_o_c_p_solver.html" title="Optimal control problem solver by Riccati recursion.">robotoc::OCPSolver</a></code>.</li>
</ul>
</li>
<li><b>Riccati recursion to compute Newton steps</b> [2, 4]:<ul>
<li>Computes the Newton steps with linear time complexity with respect to the length of the horizon.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="unconstr_ocp_solver_formulation"></a>
Methematical formulation</h2>
<p >TODO</p>
<h2><a class="anchor" id="unconstr_ocp_solver_algorithm"></a>
Solution algorithm</h2>
<p >TODO</p>
<h1><a class="anchor" id="unconstr_parnmpc_solver"></a>
robotoc::UnconstrParNMPCSolver</h1>
<h2><a class="anchor" id="unconstr_parnmpc_solver_features"></a>
Features</h2>
<p ><code><a class="el" href="classrobotoc_1_1_unconstr_par_n_m_p_c_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by ParNMPC algorithm....">robotoc::UnconstrParNMPCSolver</a></code> is an optimal control solver for robot systems without rigid contacts or a floating base. This is recommended than <code><a class="el" href="classrobotoc_1_1_unconstr_o_c_p_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by Riccati recursion....">robotoc::UnconstrOCPSolver</a></code> if the available number of CPU cores are very large. The unique features of <code><a class="el" href="classrobotoc_1_1_unconstr_par_n_m_p_c_solver.html" title="Optimal control problem solver of unconstrained rigid-body systems by ParNMPC algorithm....">robotoc::UnconstrParNMPCSolver</a></code> are:</p><ul>
<li><b>Inverse dynamics based formulation</b> [10]:<ul>
<li>Inverse dynamics-based formulation enables very fast computation compared with the forward dynamics-based formulation.</li>
</ul>
</li>
<li><b>Highly parallelizable Newton-type method</b> [5]:<ul>
<li>This method can parallelize all steps of Newton-step computation while the Riccati recursion needs serial computation in solving the KKT system. Note that the convergence speed can decrease because this method introduces an approximation for parallelization.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="unconstr_parnmpc_solver_formulation"></a>
Methematical formulation</h2>
<p >TODO</p>
<h2><a class="anchor" id="unconstr_parnmpc_solver_algorithm"></a>
Solution algorithm</h2>
<p >TODO</p>
<h1><a class="anchor" id="features_references"></a>
References</h1>
<p >[1] H. Bock and K. Plitt, "A multiple shooting algorithm for direct solution of optimal control problems," in 9th IFAC World Congress, pp.1603–1608, 1984. <br  />
 [2] J. B. Rawlings, D. Q. Mayne, and M. Diehl, <em>Model Predictive Control: Theory, Computation, and Design</em>, 2nd edition, Nob Hill Publishing, 2017. <br  />
 [3] J. Nocedal and S. J. Wright, <em>Numerical Optimization</em>, 2nd edition, Springer, 2006. <br  />
 [4] C. Rao, S. J. Wright, and J. B. Rawlings, "Application of interior-point methods to model predictive control," <em>Journal of Optimization Theory and Applications</em>, vol. 99, no. 3, pp. 723–757, 1998. <br  />
 [5] H. Deng and T. Ohtsuka, "A parallel Newton-type method for nonlinear model predictive control," <em>Automatica</em>, Vol. 109, pp. 108560, 2019. <br  />
 [6] J. Carpentier and N. Mansard, "Analytical derivatives of rigid body dynamics algorithms," Robotics: Science and Systems, 2018. <br  />
 [7] S. Katayama and T. Ohtsuka, "Lifted contact dynamics for efficient optimal control of rigid body systems with contacts," 2022 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (to appear), <a href="https://arxiv.org/abs/2108.01781">https://arxiv.org/abs/2108.01781</a>, 2022 <br  />
 [8] S. Katayama and T. Ohtsuka, "Structure-exploiting Newton-type method for optimal control of switched systems," <a href="https://arxiv.org/abs/2112.07232">https://arxiv.org/abs/2112.07232</a>, 2021. <br  />
 [9] S. Katayama and T. Ohtsuka, "Efficient Riccati recursion for optimal control problems with pure-state equality constraints," 2022 American Control Conference (ACC), pp. 3579-3586, 2022 <br  />
 [10] S. Katayama and T. Ohtsuka, "Efficient solution method based on inverse dynamics for optimal control problems of rigid body systems," 2021 IEEE International Conference on Robotics and Automation (ICRA), pp.2070-2076, 2021. <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
