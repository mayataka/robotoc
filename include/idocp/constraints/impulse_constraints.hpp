#ifndef IDOCP_IMPULSE_CONSTRAINTS_HPP_
#define IDOCP_IMPULSE_CONSTRAINTS_HPP_

#include <vector>
#include <memory>

#include "idocp/robot/robot.hpp"
#include "idocp/impulse/impulse_split_solution.hpp"
#include "idocp/impulse/impulse_split_direction.hpp"
#include "idocp/constraints/impulse_constraint_component_base.hpp"
#include "idocp/constraints/constraint_component_data.hpp"
#include "idocp/constraints/constraints_data.hpp"
#include "idocp/impulse/impulse_split_kkt_residual.hpp"
#include "idocp/impulse/impulse_split_kkt_matrix.hpp"


namespace idocp {

///
/// @class ImpulseConstraints 
/// @brief Stack of the inequality constraints. Composed by constraint 
/// components that inherits ImpulseConstraintComponentBase.
///
class ImpulseConstraints {
public:
  using ImpulseConstraintComponentBasePtr 
      = std::shared_ptr<ImpulseConstraintComponentBase>;

  ///
  /// @brief Default constructor. 
  ///
  ImpulseConstraints();

  ///
  /// @brief Destructor. 
  ///
  ~ImpulseConstraints();

  ///
  /// @brief Default copy constructor. 
  ///
  ImpulseConstraints(const ImpulseConstraints&) = default;

  ///
  /// @brief Default copy operator. 
  ///
  ImpulseConstraints& operator=(const ImpulseConstraints&) = default;

  ///
  /// @brief Default move constructor. 
  ///
  ImpulseConstraints(ImpulseConstraints&&) noexcept = default;

  ///
  /// @brief Default move assign operator. 
  ///
  ImpulseConstraints& operator=(ImpulseConstraints&&) noexcept = default;

  ///
  /// @brief Append a constraint component to the cost function.
  /// @param[in] constraint shared pointer to the constraint component appended 
  /// to the constraints.
  ///
  void push_back(const ImpulseConstraintComponentBasePtr& constraint);

  ///
  /// @brief Clear constraints by removing all components.
  ///
  void clear();

  ///
  /// @brief Creates ConstraintsData according to robot model and constraint 
  /// components. 
  /// @param[in] robot Robot model.
  /// @return ImpulseConstraints data.
  ///
  ConstraintsData createConstraintsData(const Robot& robot) const;

  ///
  /// @brief Check whether the current solution s is feasible or not. 
  /// @param[in] robot Robot model.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] s Split solution.
  /// @return true if s is feasible. false if not.
  ///
  bool isFeasible(Robot& robot, ConstraintsData& data,
                  const ImpulseSplitSolution& s) const;

  ///
  /// @brief Set the slack and dual variables of each constraint components. 
  /// @param[in] robot Robot model.
  /// @param[out] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  ///
  void setSlackAndDual(Robot& robot, ConstraintsData& data, 
                       const ImpulseSplitSolution& s) const;

  ///
  /// @brief Augment the dual residual of the constraints to the KKT residual 
  /// with respect to the configuration, velocity, acceleration, and contact 
  /// forces.
  /// @param[in] robot Robot model.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @param[out] kkt_residual KKT residual.
  ///
  void augmentDualResidual(Robot& robot, ConstraintsData& data,
                           const ImpulseSplitSolution& s,
                           ImpulseSplitKKTResidual& kkt_residual) const;

  ///
  /// @brief Consense slack and dual of the constraints and factorize condensed
  /// KKT Hessian and residual with respect to the configuration, velocity, 
  /// acceleration, and contact forces. 
  /// @param[in] robot Robot model.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData(). residual and duality are also 
  /// computed.
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @param[out] kkt_matrix The KKT matrix. The condensed Hessians are added  
  /// to this data.
  /// @param[out] kkt_residual KKT residual. The condensed residual are added 
  /// to this data.
  ///
  void condenseSlackAndDual(Robot& robot, ConstraintsData& data,
                            const ImpulseSplitSolution& s,
                            ImpulseSplitKKTMatrix& kkt_matrix, 
                            ImpulseSplitKKTResidual& kkt_residual) const;

  ///
  /// @brief Compute directions of slack and dual.
  /// @param[in] robot Robot model.
  /// @param[in, out] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @param[in] d Split direction.
  ///
  void computeSlackAndDualDirection(Robot& robot, ConstraintsData& data, 
                                    const ImpulseSplitSolution& s,
                                    const ImpulseSplitDirection& d) const;

  ///
  /// @brief Compute and returns the maximum step size by applying 
  /// fraction-to-boundary-rule to the direction of slack.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @return Maximum step size of the slack.
  ///
  double maxSlackStepSize(const ConstraintsData& data) const;

  ///
  /// @brief Compute and returns the maximum step size by applying 
  /// fraction-to-boundary-rule to the direction of dual.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @return Maximum step size of the dual.
  ///
  double maxDualStepSize(const ConstraintsData& data) const;

  ///
  /// @brief Updates the slack with step_size.
  /// @param[in, out] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] step_size Step size. 
  ///
  void updateSlack(ConstraintsData& data, const double step_size) const;

  ///
  /// @brief Updates the dual with step_size.
  /// @param[in, out] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] step_size Step size. 
  ///
  void updateDual(ConstraintsData& data, const double step_size) const;

  ///
  /// @brief Computes and returns the value of the barrier function for slack 
  /// variables.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @return Value of the barrier function. 
  ///
  double costSlackBarrier(const ConstraintsData& data) const;

  ///
  /// @brief Computes and returns the value of the barrier function for slack 
  /// variables with the step_size.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] step_size Step size. 
  /// @return Value of the barrier function. 
  ///
  double costSlackBarrier(const ConstraintsData& data, 
                          const double step_size) const;

  ///
  /// @brief Computes the primal and dual residual of the constraints. 
  /// @param[in] robot Robot model.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  ///
  void computePrimalAndDualResidual(Robot& robot, ConstraintsData& data, 
                                    const ImpulseSplitSolution& s) const;

  ///
  /// @brief Return the L1-norm of the primal residual of the constraints.
  /// before calling this function, ImpulseConstraints::computePrimalAndDualResidual 
  /// or ImpulseConstraints::condenseSlackAndDual must be called.
  /// @param[in] data ImpulseConstraints data generated by 
  /// @return L1 norm of the primal residual and duality of the constraints. 
  ///
  double l1NormPrimalResidual(const ConstraintsData& data) const;

  ///
  /// @brief Returns the squared norm of the primal residual and duality of the 
  /// constraints. Before call this function, 
  /// ImpulseConstraints::computePrimalAndDualResidual or 
  /// ImpulseConstraints::condenseSlackAndDual must be called.
  /// @param[in] data ImpulseConstraints data generated by 
  /// ImpulseConstraints::createConstraintsData().
  /// @return Squared norm of the primal residual and duality of the constraints. 
  ///
  double squaredNormPrimalAndDualResidual(const ConstraintsData& data) const;

private:
  std::vector<ImpulseConstraintComponentBasePtr> position_level_constraints_, 
                                                 velocity_level_constraints_, 
                                                 acceleration_level_constraints_;

  static void clear_impl(
      std::vector<ImpulseConstraintComponentBasePtr>& constraints);

  static bool useKinematics_impl(
      const std::vector<ImpulseConstraintComponentBasePtr>& constraints);

  static bool isFeasible_impl(
    const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
    Robot& robot, std::vector<ConstraintComponentData>& data, 
    const ImpulseSplitSolution& s);

  static void setSlackAndDual_impl(
    const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
    Robot& robot, std::vector<ConstraintComponentData>& data, 
    const ImpulseSplitSolution& s);

  static void augmentDualResidual_impl(
    const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
    Robot& robot, std::vector<ConstraintComponentData>& data, 
    const ImpulseSplitSolution& s, ImpulseSplitKKTResidual& kkt_residual);

  static void condenseSlackAndDual_impl(
    const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
    Robot& robot, std::vector<ConstraintComponentData>& data, 
    const ImpulseSplitSolution& s, ImpulseSplitKKTMatrix& kkt_matrix, 
    ImpulseSplitKKTResidual& kkt_residual);

  static void computeSlackAndDualDirection_impl(
    const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
    Robot& robot, std::vector<ConstraintComponentData>& data, 
    const ImpulseSplitSolution& s, const ImpulseSplitDirection& d);

  static double maxSlackStepSize_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     const std::vector<ConstraintComponentData>& data);

  static double maxDualStepSize_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     const std::vector<ConstraintComponentData>& data);

  static void updateSlack_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     std::vector<ConstraintComponentData>& data, const double step_size);

  static void updateDual_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     std::vector<ConstraintComponentData>& data, const double step_size);

  static double costSlackBarrier_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     const std::vector<ConstraintComponentData>& data);

  static double costSlackBarrier_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     const std::vector<ConstraintComponentData>& data, 
     const double step_size);

  static void computePrimalAndDualResidual_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     Robot& robot, std::vector<ConstraintComponentData>& data, 
     const ImpulseSplitSolution& s);

  static double l1NormPrimalResidual_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     const std::vector<ConstraintComponentData>& data);

  static double squaredNormPrimalAndDualResidual_impl(
     const std::vector<ImpulseConstraintComponentBasePtr>& constraints,
     const std::vector<ConstraintComponentData>& data);

};

} // namespace idocp

#include "idocp/constraints/impulse_constraints.hxx"

#endif // IDOCP_IMPULSE_CONSTRAINTS_HPP_ 